apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'cpp'
apply plugin: 'idea'
apply plugin: 'application'
apply plugin: 'maven'

repositories {
    mavenCentral()
}

dependencies {
    groovy 'org.codehaus.groovy:groovy:1.8.7'
    testCompile 'org.spockframework:spock-core:0.6-groovy-1.8'
}

group = 'net.rubygrapefruit'
version = '0.1'

mainClassName = 'net.rubygrapefruit.platform.Main'
def nativeHeadersDir = file("$buildDir/nativeHeaders")
sourceCompatibility = 1.5
targetCompatibility = 1.5

configurations.compile.extendsFrom = []

cpp {
    sourceSets {
        main
    }
}

libraries {
    if (org.gradle.internal.os.OperatingSystem.current().macOsX) {
        universal.spec {
            baseName = 'native-platform-osx-universal'
            includes(['/System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/'])
            args("-lcurses", "-arch", "x86_64", "-arch", "i386", "-o", outputFile)
        }
    } else if (org.gradle.internal.os.OperatingSystem.current().windows) {
        main.spec {
            baseName = 'native-platform-win32'
            includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include"])
            includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include/win32"])
            args("/DWIN32")
        }
    } else if (org.gradle.internal.os.OperatingSystem.current().linux) {
        all {
            spec {
                includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include"])
                includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include/linux"])
                args("-lcurses")
            }
        }
        if (System.getProperty('os.arch') == 'i386' || project.hasProperty('multiarch')) {
            i386.spec {
                baseName = 'native-platform-linux-i386'
                args("-m32")
            }
        }
        if (System.getProperty('os.arch') == 'amd64' || project.hasProperty('multiarch')) {
            amd64.spec {
                baseName = 'native-platform-linux-amd64'
                args("-m64")
            }
        }
    } else {
        baseName = "native-platform-solaris"
        main.spec {
            includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include"])
            includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include/solaris"])
            args("-DSOLARIS", "-lcurses")
        }
    }
    all {
        spec {
            includes([nativeHeadersDir])
        }
        sourceSets << cpp.sourceSets.main
    }
}

task nativeHeaders {
    def outputFile = file("$nativeHeadersDir/native.h")
    inputs.files sourceSets.main.output
    outputs.file outputFile
    doLast {
        outputFile.parentFile.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-o', outputFile
            args '-classpath', sourceSets.main.output.classesDir
            args 'net.rubygrapefruit.platform.internal.jni.NativeLibraryFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixFileFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixFileSystemFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixProcessFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixTerminalFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.TerminfoFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.WindowsConsoleFunctions'
        }
    }
}

def deployer = null
uploadArchives {
    repositories {
        deployer = mavenDeployer {
            repository(url: uri("$buildDir/repo"))
        }
    }
}

libraries.all { lib ->
    def nativeJar = task("nativeJar${lib.name.capitalize()}", type: Jar) {
        from lib.spec.task
        baseName = lib.spec.baseName
    }
    startScripts.classpath += nativeJar.outputs.files
    applicationDistribution.from(nativeJar) {
        into 'lib'
    }
    lib.spec.task.dependsOn nativeHeaders
    test.dependsOn lib.spec.task
    artifacts {
        archives nativeJar
    }
    def jniPom = deployer.addFilter(lib.name) { artifact, file ->
        return file == nativeJar.archivePath
    }
    jniPom.groupId = project.group
    jniPom.artifactId = lib.spec.baseName
    jniPom.version = project.version
    jniPom.scopeMappings.mappings.clear()
}

javadoc {
    exclude '**/internal/**'
}

applicationDistribution.from(javadoc) {
    into 'javadoc'
}

artifacts {
    archives distZip
}

def mainPom = deployer.addFilter('main') { artifact, file ->
    return file == distZip.archivePath || file == jar.archivePath
}
mainPom.groupId = project.group
mainPom.artifactId = jar.baseName
mainPom.version = project.version
mainPom.scopeMappings.mappings.clear()
mainPom.withXml { provider ->
    def node = provider.asNode()
    def deps = node.appendNode('dependencies')
    def dep = deps.appendNode('dependency')
    dep.appendNode('groupId', project.group)
    dep.appendNode('artifactId', 'native-platform-osx-universal')
    dep.appendNode('version', project.version)
}
