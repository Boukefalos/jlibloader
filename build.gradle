apply plugin: 'groovy'
apply plugin: 'cpp'

allprojects {
    apply plugin: 'java'
    apply plugin: 'idea'
    apply plugin: 'maven'

    repositories {
        mavenCentral()
        maven { url "https://gradle.artifactoryonline.com/gradle/libs-releases-local" }
    }

    dependencies {
        testCompile 'org.spockframework:spock-core:0.6-groovy-1.8'
    }

    group = 'net.rubygrapefruit'
    version = '0.2'

    sourceCompatibility = 1.5
    targetCompatibility = 1.5

    configurations.compile.extendsFrom = []

    tasks.withType(Upload) {
        repositories {
            mavenDeployer {
                if (project.hasProperty('release')) {
                    repository(url: uri("https://gradle.artifactoryonline.com/gradle/libs-releases-local")) {
                        authentication(userName: artifactoryUserName, password: artifactoryPassword)
                    }
                } else {
                    repository(url: uri("$rootProject.buildDir/repo"))
                }
            }
        }
    }
}

dependencies {
    groovy 'org.codehaus.groovy:groovy:1.8.7'
}

def nativeHeadersDir = file("$buildDir/nativeHeaders")

cpp {
    sourceSets {
        main
    }
}

libraries {
    if (org.gradle.internal.os.OperatingSystem.current().macOsX) {
        universal.spec {
            baseName = 'native-platform-osx-universal'
            includes(['/System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/'])
            args("-lcurses", "-arch", "x86_64", "-arch", "i386", "-o", outputFile)
        }
    } else if (org.gradle.internal.os.OperatingSystem.current().windows) {
        all {
            spec {
                includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include"])
                includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include/win32"])
                args("/DWIN32")
            }
        }

        def out = new ByteArrayOutputStream()
        exec {
            commandLine "cl.exe", "/?"
            errorOutput = out
            standardOutput = new ByteArrayOutputStream()
        }
        def header = out.toString().readLines().head()
        if (header.endsWith("for 80x86") || header.endsWith("for x86")) {
            i386.spec {
                baseName = 'native-platform-windows-i386'
            }
        } else if (header.endsWith("for x64")) {
            amd64.spec {
                baseName = 'native-platform-windows-amd64'
            }
        } else {
            throw new RuntimeException("Cannot determine compiler's target architecture")
        }

    } else if (org.gradle.internal.os.OperatingSystem.current().linux) {
        all {
            spec {
                includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include"])
                includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include/linux"])
                args("-lcurses")
            }
        }
        if (System.getProperty('os.arch') == 'i386' || project.hasProperty('multiarch')) {
            i386.spec {
                baseName = 'native-platform-linux-i386'
                args("-m32")
            }
        }
        if (System.getProperty('os.arch') == 'amd64' || project.hasProperty('multiarch')) {
            amd64.spec {
                baseName = 'native-platform-linux-amd64'
                args("-m64")
            }
        }
    } else {
        baseName = "native-platform-solaris"
        main.spec {
            includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include"])
            includes(["${org.gradle.internal.jvm.Jvm.current().javaHome}/include/solaris"])
            args("-DSOLARIS", "-lcurses")
        }
    }
    all {
        spec {
            includes([nativeHeadersDir])
        }
        sourceSets << cpp.sourceSets.main
    }
}

task nativeHeaders {
    def outputFile = file("$nativeHeadersDir/native.h")
    inputs.files sourceSets.main.output
    outputs.file outputFile
    doLast {
        outputFile.parentFile.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-o', outputFile
            args '-classpath', sourceSets.main.output.classesDir
            args 'net.rubygrapefruit.platform.internal.jni.NativeLibraryFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixFileFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixFileSystemFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixProcessFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixTerminalFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.TerminfoFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.WindowsConsoleFunctions'
        }
    }
}

configurations {
    jni
}

def deployer = uploadJni.repositories.mavenDeployer

libraries.all { lib ->
    def nativeJar = task("nativeJar${lib.name.capitalize()}", type: Jar) {
        from lib.spec.task
        baseName = lib.spec.baseName
    }
    lib.spec.task.dependsOn nativeHeaders
    test.dependsOn lib.spec.task
    artifacts {
        jni nativeJar
        runtime nativeJar
    }
    def jniPom = deployer.addFilter(lib.name) { artifact, file ->
        return file == nativeJar.archivePath
    }
    jniPom.groupId = project.group
    jniPom.artifactId = lib.spec.baseName
    jniPom.version = project.version
    jniPom.scopeMappings.mappings.clear()
}

javadoc {
    exclude '**/internal/**'
}

task sourceZip(type: Zip) {
    from sourceSets.main.allSource
    classifier = 'source'
}

task javadocZip(type: Zip) {
    from javadoc
    classifier = 'javadoc'
}

artifacts {
    archives sourceZip
    archives javadocZip
}

def mainPom = uploadArchives.repositories.mavenDeployer.pom
mainPom.groupId = project.group
mainPom.artifactId = jar.baseName
mainPom.version = project.version
mainPom.scopeMappings.mappings.clear()
mainPom.withXml { provider ->
    def node = provider.asNode()
    def deps = node.appendNode('dependencies')
    ['osx-universal', 'linux-amd64', 'linux-i386', 'windows-amd64', 'windows-i386'].each { platform ->
        def dep = deps.appendNode('dependency')
        dep.appendNode('groupId', project.group)
        dep.appendNode('artifactId', "native-platform-${platform}")
        dep.appendNode('version', project.version)
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = "1.3-20120907220018+0000"
}
